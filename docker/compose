#!/usr/bin/env bash
# =============================================================================
# Compose Wrapper Script
# =============================================================================
#
# A simple wrapper for Docker Compose that provides enhanced functionality
# through conventions-based configuration.
#
# Features:
#   - Universal access - works from any directory in the repository
#   - Info command with connection information from service labels
#   - Environment variable loading (.env, .env.local support)
#   - Convention validation (compose.yaml location)
#   - Port conflict detection and troubleshooting
#   - Visual output formatting and progress indicators
#
# =============================================================================

# Enable strict error handling
set -Eeuo pipefail
IFS=$'\n\t'

#------------------------------------------------------------------------------
# Constants and Colors
#------------------------------------------------------------------------------
readonly RED=$'\e[0;31m'
readonly GREEN=$'\e[0;32m'
readonly YELLOW=$'\e[0;33m'
readonly BLUE=$'\e[0;34m'
readonly BOLD=$'\e[1m'
readonly NC=$'\e[0m'

#------------------------------------------------------------------------------
# Logging Functions
#------------------------------------------------------------------------------
log() {
    local level="$1"
    shift
    local color prefix
    
    case "$level" in
        error)   color="$RED"    ; prefix="✗ " ;;
        success) color="$GREEN"  ; prefix="✓ " ;;
        warn)    color="$YELLOW" ; prefix="! " ;;
        info)    color="$BLUE"   ; prefix="→ " ;;
        header)  color="$BLUE"   ; prefix="== " ;;
        *)       color="$NC"     ; prefix="  " ;;
    esac
    
    printf "%b%s%s%b\n" "$color" "$prefix" "$*" "$NC"
}

#------------------------------------------------------------------------------
# Dependency Checks
#------------------------------------------------------------------------------
require_cmd() {
    if ! command -v "$1" &>/dev/null; then
        log error "Required command '$1' not found"
        log info "Please install $1 and try again"
        exit 1
    fi
}

check_dependencies() {
    require_cmd docker
    require_cmd yq
    require_cmd jq
}

#------------------------------------------------------------------------------
# Script Location and Convention Validation
#------------------------------------------------------------------------------
get_script_dir() {
    local script_path="${BASH_SOURCE[0]}"
    
    # Resolve symlinks to get the actual script location
    # This handles cases where the script is symlinked from other directories
    # (e.g., when script is in PATH or accessed via symbolic links)
    while [[ -L "$script_path" ]]; do
        local link_dir
        link_dir=$(dirname "$script_path")
        script_path=$(readlink "$script_path")
        
        # Handle relative symlinks by making them absolute
        # If readlink returns a relative path, prepend the link's directory
        if [[ "$script_path" != /* ]]; then
            script_path="$link_dir/$script_path"
        fi
    done
    
    dirname "$script_path"
}

check_compose_file() {
    local script_dir
    script_dir=$(get_script_dir)
    local compose_file="$script_dir/compose.yaml"
    
    if [[ ! -f "$compose_file" ]]; then
        log error "compose.yaml not found next to compose script"
        log info "Expected location: $compose_file"
        log info "This script requires a compose.yaml file in the same directory"
        exit 1
    fi
}

# Profile validation removed - system now starts all services together

validate_conventions() {
    check_compose_file
}

#------------------------------------------------------------------------------
# Environment Loading
#------------------------------------------------------------------------------
load_env() {
    local script_dir
    script_dir=$(get_script_dir)
    
    # Auto-export all variables set in env files so Docker Compose can use them
    set -a  
    
    # Load .env if it exists (team defaults, committed to git)
    # The [[ ]] test prevents errors if the file doesn't exist
    [[ -f "$script_dir/.env" ]] && source "$script_dir/.env"
    
    # Load .env.local if it exists (personal overrides, gitignored)
    # This file takes precedence over .env for the same variables
    [[ -f "$script_dir/.env.local" ]] && source "$script_dir/.env.local"
    
    # Stop auto-exporting variables for the rest of the script
    set +a
}

#------------------------------------------------------------------------------
# Docker Compose Wrapper
#------------------------------------------------------------------------------
docker_compose() {
    local script_dir
    script_dir=$(get_script_dir)
    
    # Run docker compose from the script directory (not current working directory)
    # The subshell (parentheses) ensures we don't change the caller's working directory
    # 'command' prevents any potential docker compose function/alias conflicts
    (cd "$script_dir" && command docker compose "$@")
}

#------------------------------------------------------------------------------
# Visual Output
#------------------------------------------------------------------------------
show_operation_header() {
    local operation="$1"
    log header "$operation"
}

#------------------------------------------------------------------------------
# Service Info Processing
#------------------------------------------------------------------------------
process_service_info_json() {
    local service="$1"
    local info_json="$2"
    
    # Extract title
    local title
    title=$(echo "$info_json" | jq -r '.title // empty')
    
    if [[ -n "$title" ]]; then
        log success "$title"
        
        # Extract and display URLs from the info.url.* labels
        # jq breakdown: .url // {} = get .url object or empty object if null
        #               to_entries[] = convert {key:value} to [{key:"key", value:"value"}]
        #               "\(.key): \(.value)" = format as "key: value" strings
        local urls
        urls=$(echo "$info_json" | jq -r '.url // {} | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || true)
        if [[ -n "$urls" ]]; then
            # Read each URL line and display with indentation
            while IFS= read -r url_line; do
                printf "    → %s\n" "$url_line"
            done <<< "$urls"  # Here-string to pass urls to the while loop
        fi
        
        # Extract and display credentials from the info.cred.* labels
        # Same jq pattern as URLs above
        local creds
        creds=$(echo "$info_json" | jq -r '.cred // {} | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || true)
        if [[ -n "$creds" ]]; then
            # Read each credential line and display with indentation
            while IFS= read -r cred_line; do
                printf "    → %s\n" "$cred_line"
            done <<< "$creds"  # Here-string to pass creds to the while loop
        fi
        
        echo
    fi
}

#------------------------------------------------------------------------------
# Usage Information
#------------------------------------------------------------------------------
show_usage() {
    cat << 'EOF'
Usage: compose <command> [options]

Commands:
  up                    Start all services (detached mode)
  down                  Stop all services
  ps                    Show service status
  logs                  Show service logs (-f for follow)
  build                 Build service images
  clean                 Stop services and remove volumes
  info                  Show connection information for all services

Examples:
  compose up                    # Start all services
  compose info                  # Show all service connection information
  compose clean                 # Remove all services and volumes
  compose logs -f               # Follow all service logs

Environment:
  Override defaults via .env, .env.local, or shell variables
  Example: PG_PORT=5432 compose up
EOF
}

#------------------------------------------------------------------------------
# Main Command Handler
#------------------------------------------------------------------------------
main() {
    # Check dependencies and validate conventions
    check_dependencies
    validate_conventions
    
    # Load environment variables
    load_env
    
    # Parse command and arguments
    local cmd="${1:-}"
    if [[ -z "$cmd" ]]; then
        show_usage
        exit 1
    fi
    shift
    
    case "$cmd" in
        up|down|ps|logs|build)
            # Capitalize the first letter of the command for display
            # ${cmd:0:1} = first character, ${cmd:1} = rest of string
            # tr converts first char to uppercase
            show_operation_header "$(tr '[:lower:]' '[:upper:]' <<< "${cmd:0:1}")${cmd:1}"
            
            if [[ "$cmd" == "up" ]]; then
                # Try to start services, handle port conflicts
                if ! docker_compose "up" -d "$@"; then
                    log error "Failed to start services - likely port conflicts"
                    log info "Check running containers with: docker ps"
                    log info "Stop conflicting services or change ports in .env"
                    exit 1
                fi
                log success "Services started successfully"
            else
                docker_compose "$cmd" "$@"
            fi
            ;;
            
        clean)
            show_operation_header "Cleaning"
            docker_compose "down" -v --remove-orphans
            log success "Cleanup completed"
            ;;
            
        info)
            log header "Service Connection Information"
            
            # COMPLEX JQ PIPELINE: Extract service info from Docker Compose configuration
            # This is the most complex part of the script - here's how it works:
            #
            # 1. docker_compose config --format json = get complete compose config as JSON
            # 2. .services | to_entries = convert services object to array of {key, value} pairs
            # 3. map({service: .key, info: ...}) = transform each service entry
            # 4. For the info section:
            #    a. (.value.labels // {}) = get service labels or empty object
            #    b. | to_entries = convert labels to array of {key, value} pairs  
            #    c. | map(select(.key|startswith("info."))) = keep only info.* labels
            #    d. | map({path: (.key | split(".")[1:]), value: .value}) = convert "info.group.Database" to {path:["group","Database"], value:"..."}
            #    e. | reduce .[] as $i ({}; setpath($i.path; $i.value)) = rebuild nested object from paths
            #
            # Example: "info.url.jdbc=jdbc://..." becomes {url: {jdbc: "jdbc://..."}}
            local services_json
            services_json=$(docker_compose config --format json 2>/dev/null | jq '.services
                           | to_entries
                           | map({
                               service: .key,
                               info:
                                 ((.value.labels // {})
                                  | to_entries
                                  | map(select(.key|startswith("info.")))
                                  | map({path: (.key | split(".")[1:]), value: .value})
                                  | reduce .[] as $i ({}; setpath($i.path; $i.value))
                                 )
                             })' 2>/dev/null)
            
            if [[ -n "$services_json" && "$services_json" != "null" ]]; then
                echo
                
                # GROUP SERVICES BY info.group LABEL AND DISPLAY
                # This groups services by their info.group label for organized output
                #
                # jq breakdown:
                # 1. group_by(.info.group // "Other") = group services by group label, default to "Other"
                # 2. map({group: (.[0].info.group // "Other"), services: .}) = create {group: "name", services: [...]} objects
                local groups_json
                groups_json=$(echo "$services_json" | jq 'group_by(.info.group // "Other") | map({group: (.[0].info.group // "Other"), services: .})')
                
                # Process each group: extract group name and services as tab-separated values
                # @json ensures the services array is properly JSON-encoded for later parsing
                echo "$groups_json" | jq -r '.[] | "\(.group)\t\(.services | @json)"' | while IFS=$'\t' read -r group services_in_group; do
                    # Display group header in red color
                    printf "%b== %s%b\n\n" "$RED" "$group" "$NC"
                    
                    # Process each service in this group
                    # select(.info.title) = only show services that have a title label
                    # Output format: "service_name<TAB>info_json" for parsing
                    echo "$services_in_group" | jq -r '.[] | select(.info.title) | "\(.service)\t\(.info | @json)"' | while IFS=$'\t' read -r service info_json; do
                        process_service_info_json "$service" "$info_json"
                    done
                done
            else
                log warn "No services found"
            fi
            ;;
            
        help|--help|-h)
            show_usage
            ;;
            
        *)
            log error "Unknown command: $cmd"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"