#!/usr/bin/env bash
# =============================================================================
# Compose Wrapper Script
# =============================================================================
#
# A simple wrapper for Docker Compose that provides enhanced functionality
# through conventions-based configuration and profile management.
#
# Features:
#   - Profile-based service management (default, all, db, mcp, observability)
#   - Status command with connection information from service labels
#   - Environment variable loading (.env, .env.local support)
#   - Convention validation (compose.yaml, service profiles)
#   - Port conflict detection and troubleshooting
#   - Visual output formatting and progress indicators
#
# =============================================================================

# Enable strict error handling
set -Eeuo pipefail
IFS=$'\n\t'

#------------------------------------------------------------------------------
# Constants and Colors
#------------------------------------------------------------------------------
readonly RED=$'\e[0;31m'
readonly GREEN=$'\e[0;32m'
readonly YELLOW=$'\e[0;33m'
readonly BLUE=$'\e[0;34m'
readonly BOLD=$'\e[1m'
readonly NC=$'\e[0m'

#------------------------------------------------------------------------------
# Logging Functions
#------------------------------------------------------------------------------
log() {
    local level="$1"
    shift
    local color prefix
    
    case "$level" in
        error)   color="$RED"    ; prefix="✗ " ;;
        success) color="$GREEN"  ; prefix="✓ " ;;
        warn)    color="$YELLOW" ; prefix="! " ;;
        info)    color="$BLUE"   ; prefix="→ " ;;
        header)  color="$BLUE"   ; prefix="== " ;;
        *)       color="$NC"     ; prefix="  " ;;
    esac
    
    printf "%b%s%s%b\n" "$color" "$prefix" "$*" "$NC"
}

#------------------------------------------------------------------------------
# Dependency Checks
#------------------------------------------------------------------------------
require_cmd() {
    if ! command -v "$1" &>/dev/null; then
        log error "Required command '$1' not found"
        log info "Please install $1 and try again"
        exit 1
    fi
}

check_dependencies() {
    require_cmd docker
    require_cmd yq
    require_cmd jq
}

#------------------------------------------------------------------------------
# Convention Validation
#------------------------------------------------------------------------------
check_compose_file() {
    if [[ ! -f compose.yaml ]]; then
        log error "compose.yaml not found in current directory"
        log info "This script requires a compose.yaml file (exact filename)"
        exit 1
    fi
}

check_service_profiles() {
    local services_without_profiles
    services_without_profiles=$(yq '.services | to_entries | map(select(.value.profiles == null)) | .[].key' compose.yaml 2>/dev/null)
    
    if [[ -n "$services_without_profiles" ]]; then
        log error "Services missing explicit profiles:"
        echo "$services_without_profiles" | while read -r service; do
            log error "  - $service"
        done
        log info "All services must have explicit 'profiles: [...]' set"
        exit 1
    fi
}

validate_conventions() {
    check_compose_file
    check_service_profiles
}

#------------------------------------------------------------------------------
# Environment Loading
#------------------------------------------------------------------------------
load_env() {
    set -a  # Auto-export variables
    
    # Load .env if it exists (team defaults)
    [[ -f .env ]] && source .env
    
    # Load .env.local if it exists (personal overrides)
    [[ -f .env.local ]] && source .env.local
    
    set +a  # Stop auto-export
}

#------------------------------------------------------------------------------
# Profile Management
#------------------------------------------------------------------------------
get_profiles() {
    docker compose config --profiles 2>/dev/null | sort
}

parse_profiles() {
    local profiles=("$@")
    
    # If no profiles specified, use default
    if [[ ${#profiles[@]} -eq 0 ]]; then
        echo "default"
        return
    fi
    
    # Return specified profiles
    local IFS=' '
    echo "${profiles[*]}"
}

#------------------------------------------------------------------------------
# Docker Compose Wrapper
#------------------------------------------------------------------------------
docker_compose_with_profiles() {
    local cmd="$1"
    local profiles_string="$2"
    shift 2
    local remaining_args=("$@")
    
    # Build profile arguments array
    local profile_args=()
    for profile in $profiles_string; do
        profile_args+=(--profile "$profile")
    done
    
    # Execute docker compose with profile arguments before command
    docker compose "${profile_args[@]}" "$cmd" "${remaining_args[@]}"
}

#------------------------------------------------------------------------------
# Visual Output
#------------------------------------------------------------------------------
show_profile_divider() {
    local profiles="$1"
    local operation="${2:-Operation}"
    
    if [[ "$profiles" == "default" ]]; then
        log header "$operation (default profile)"
    elif [[ "$profiles" =~ \  ]]; then
        log header "$operation ($profiles profiles)"
    else
        log header "$operation ($profiles profile)"
    fi
}

#------------------------------------------------------------------------------
# Service Info Processing
#------------------------------------------------------------------------------
process_service_info_json() {
    local service="$1"
    local info_json="$2"
    
    # Extract title
    local title
    title=$(echo "$info_json" | jq -r '.title // empty')
    
    if [[ -n "$title" ]]; then
        log success "$title"
        
        # Show URLs
        local urls
        urls=$(echo "$info_json" | jq -r '.url // {} | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || true)
        if [[ -n "$urls" ]]; then
            while IFS= read -r url_line; do
                printf "    → %s\n" "$url_line"
            done <<< "$urls"
        fi
        
        # Show credentials
        local creds
        creds=$(echo "$info_json" | jq -r '.cred // {} | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || true)
        if [[ -n "$creds" ]]; then
            while IFS= read -r cred_line; do
                printf "    → %s\n" "$cred_line"
            done <<< "$creds"
        fi
        
        echo
    fi
}

#------------------------------------------------------------------------------
# Usage Information
#------------------------------------------------------------------------------
show_usage() {
    cat << 'EOF'
Usage: compose <command> [profiles...] [options]

Commands:
  up [profiles...]      Start services (detached mode)
  down [profiles...]    Stop services
  ps [profiles...]      Show service status
  logs [profiles...]    Show service logs (-f for follow)
  build [profiles...]   Build service images
  clean [profiles...]   Stop services and remove volumes
  info                  Show connection information for all services
  profiles              List available profiles

Profiles:
  default              Core services for daily development
  all                  All services including observability
  db                   Database services only
  mcp                  MCP services only  
  observability        Observability services only

Examples:
  compose up                    # Start default services
  compose up all                # Start all services
  compose up db observability   # Start specific profiles
  compose info                  # Show all service connection information
  compose clean all             # Remove all services and volumes
  compose logs mcp -f           # Follow MCP service logs

Environment:
  Override defaults via .env, .env.local, or shell variables
  Example: MCP_SSE_PORT=5001 compose up mcp
EOF
}

#------------------------------------------------------------------------------
# Main Command Handler
#------------------------------------------------------------------------------
main() {
    # Check dependencies and validate conventions
    check_dependencies
    validate_conventions
    
    # Load environment variables
    load_env
    
    # Parse command and arguments
    local cmd="${1:-}"
    if [[ -z "$cmd" ]]; then
        show_usage
        exit 1
    fi
    shift
    
    case "$cmd" in
        up|down|ps|logs|build)
            local profiles
            profiles=$(parse_profiles "$@")
            show_profile_divider "$profiles" "$(tr '[:lower:]' '[:upper:]' <<< "${cmd:0:1}")${cmd:1}"
            
            if [[ "$cmd" == "up" ]]; then
                # Try to start services, handle port conflicts
                if ! docker_compose_with_profiles "up" "$profiles" -d; then
                    log error "Failed to start services - likely port conflicts"
                    log info "Check running containers with: docker ps"
                    log info "Stop conflicting services or change ports in .env"
                    exit 1
                fi
                log success "Services started successfully"
            else
                docker_compose_with_profiles "$cmd" "$profiles"
            fi
            ;;
            
        clean)
            local profiles
            profiles=$(parse_profiles "$@")
            show_profile_divider "$profiles" "Cleaning"
            docker_compose_with_profiles "down" "$profiles" -v --remove-orphans
            log success "Cleanup completed"
            ;;
            
        info)
            log header "Service Connection Information"
            
            # Get all services from all profiles using docker compose config
            local services_json
            services_json=$(docker compose --profile all config --format json 2>/dev/null | jq '.services
                           | to_entries
                           | map({
                               service: .key,
                               info:
                                 ((.value.labels // {})
                                  | to_entries
                                  | map(select(.key|startswith("info.")))
                                  | map({path: (.key | split(".")[1:]), value: .value})
                                  | reduce .[] as $i ({}; setpath($i.path; $i.value))
                                 )
                             })' 2>/dev/null)
            
            if [[ -n "$services_json" && "$services_json" != "null" ]]; then
                echo
                
                # Process each service
                echo "$services_json" | jq -r '.[] | select(.info.title) | "\(.service)\t\(.info | @json)"' | while IFS=$'\t' read -r service info_json; do
                    process_service_info_json "$service" "$info_json"
                done
            else
                log warn "No services found"
            fi
            ;;
            
        profiles)
            log header "Available Profiles"
            local available_profiles
            available_profiles=$(get_profiles)
            
            if [[ -n "$available_profiles" ]]; then
                echo "$available_profiles" | while read -r profile; do
                    case "$profile" in
                        default)      printf "  %-15s %s\n" "$profile" "Core services for daily development" ;;
                        all)          printf "  %-15s %s\n" "$profile" "All services including observability" ;;
                        db)           printf "  %-15s %s\n" "$profile" "Database services only" ;;
                        mcp)          printf "  %-15s %s\n" "$profile" "MCP services only" ;;
                        observability) printf "  %-15s %s\n" "$profile" "Observability services only" ;;
                        *)            printf "  %-15s %s\n" "$profile" "Custom profile" ;;
                    esac
                done
            else
                log warn "No profiles found in compose.yaml"
            fi
            ;;
            
        help|--help|-h)
            show_usage
            ;;
            
        *)
            log error "Unknown command: $cmd"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"