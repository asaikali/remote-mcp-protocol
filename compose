#!/usr/bin/env bash
# =============================================================================
# Compose Wrapper Script
# =============================================================================
#
# A simple wrapper for Docker Compose that provides enhanced functionality
# through conventions-based configuration and profile management.
#
# Features:
#   - Profile-based service management (default, all, db, mcp, observability)
#   - Status command with connection information from service labels
#   - Environment variable loading (.env, .env.local support)
#   - Convention validation (compose.yaml, service profiles)
#   - Port conflict detection and troubleshooting
#   - Visual output formatting and progress indicators
#
# =============================================================================

# Enable strict error handling
set -Eeuo pipefail
IFS=$'\n\t'

#------------------------------------------------------------------------------
# Constants and Colors
#------------------------------------------------------------------------------
readonly RED=$'\e[0;31m'
readonly GREEN=$'\e[0;32m'
readonly YELLOW=$'\e[0;33m'
readonly BLUE=$'\e[0;34m'
readonly BOLD=$'\e[1m'
readonly NC=$'\e[0m'

#------------------------------------------------------------------------------
# Logging Functions
#------------------------------------------------------------------------------
log() {
    local level="$1"
    shift
    local color prefix
    
    case "$level" in
        error)   color="$RED"    ; prefix="✗ " ;;
        success) color="$GREEN"  ; prefix="✓ " ;;
        warn)    color="$YELLOW" ; prefix="! " ;;
        info)    color="$BLUE"   ; prefix="→ " ;;
        header)  color="$BLUE"   ; prefix="== " ;;
        *)       color="$NC"     ; prefix="  " ;;
    esac
    
    printf "%b%s%s%b\n" "$color" "$prefix" "$*" "$NC"
}

#------------------------------------------------------------------------------
# Dependency Checks
#------------------------------------------------------------------------------
require_cmd() {
    if ! command -v "$1" &>/dev/null; then
        log error "Required command '$1' not found"
        log info "Please install $1 and try again"
        exit 1
    fi
}

check_dependencies() {
    require_cmd docker
    require_cmd yq
    require_cmd jq
}

#------------------------------------------------------------------------------
# Convention Validation
#------------------------------------------------------------------------------
check_compose_file() {
    if [[ ! -f compose.yaml ]]; then
        log error "compose.yaml not found in current directory"
        log info "This script requires a compose.yaml file (exact filename)"
        exit 1
    fi
}

# No longer needed - profile system removed

validate_conventions() {
    check_compose_file
}

#------------------------------------------------------------------------------
# Environment Loading
#------------------------------------------------------------------------------
load_env() {
    set -a  # Auto-export variables
    
    # Load .env if it exists (team defaults)
    [[ -f .env ]] && source .env
    
    # Load .env.local if it exists (personal overrides)
    [[ -f .env.local ]] && source .env.local
    
    set +a  # Stop auto-export
}

#------------------------------------------------------------------------------
# Docker Compose Wrapper
#------------------------------------------------------------------------------
docker_compose() {
    # Simple passthrough to docker compose
    command docker compose "$@"
}

#------------------------------------------------------------------------------
# Visual Output
#------------------------------------------------------------------------------
show_operation_header() {
    local operation="$1"
    log header "$operation"
}

#------------------------------------------------------------------------------
# Service Info Processing
#------------------------------------------------------------------------------
process_service_info_json() {
    local service="$1"
    local info_json="$2"
    
    # Extract title
    local title
    title=$(echo "$info_json" | jq -r '.title // empty')
    
    if [[ -n "$title" ]]; then
        log success "$title"
        
        # Show URLs
        local urls
        urls=$(echo "$info_json" | jq -r '.url // {} | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || true)
        if [[ -n "$urls" ]]; then
            while IFS= read -r url_line; do
                printf "    → %s\n" "$url_line"
            done <<< "$urls"
        fi
        
        # Show credentials
        local creds
        creds=$(echo "$info_json" | jq -r '.cred // {} | to_entries[] | "\(.key): \(.value)"' 2>/dev/null || true)
        if [[ -n "$creds" ]]; then
            while IFS= read -r cred_line; do
                printf "    → %s\n" "$cred_line"
            done <<< "$creds"
        fi
        
        echo
    fi
}

#------------------------------------------------------------------------------
# Usage Information
#------------------------------------------------------------------------------
show_usage() {
    cat << 'EOF'
Usage: compose <command> [options]

Commands:
  up                    Start all services (detached mode)
  down                  Stop all services
  ps                    Show service status
  logs                  Show service logs (-f for follow)
  build                 Build service images
  clean                 Stop services and remove volumes
  info                  Show connection information for all services

Examples:
  compose up                    # Start all services
  compose info                  # Show all service connection information
  compose clean                 # Remove all services and volumes
  compose logs -f               # Follow all service logs

Environment:
  Override defaults via .env, .env.local, or shell variables
  Example: PG_PORT=5432 compose up
EOF
}

#------------------------------------------------------------------------------
# Main Command Handler
#------------------------------------------------------------------------------
main() {
    # Check dependencies and validate conventions
    check_dependencies
    validate_conventions
    
    # Load environment variables
    load_env
    
    # Parse command and arguments
    local cmd="${1:-}"
    if [[ -z "$cmd" ]]; then
        show_usage
        exit 1
    fi
    shift
    
    case "$cmd" in
        up|down|ps|logs|build)
            show_operation_header "$(tr '[:lower:]' '[:upper:]' <<< "${cmd:0:1}")${cmd:1}"
            
            if [[ "$cmd" == "up" ]]; then
                # Try to start services, handle port conflicts
                if ! docker_compose "up" -d "$@"; then
                    log error "Failed to start services - likely port conflicts"
                    log info "Check running containers with: docker ps"
                    log info "Stop conflicting services or change ports in .env"
                    exit 1
                fi
                log success "Services started successfully"
            else
                docker_compose "$cmd" "$@"
            fi
            ;;
            
        clean)
            show_operation_header "Cleaning"
            docker_compose "down" -v --remove-orphans
            log success "Cleanup completed"
            ;;
            
        info)
            log header "Service Connection Information"
            
            # Get all services using docker compose config
            local services_json
            services_json=$(docker compose config --format json 2>/dev/null | jq '.services
                           | to_entries
                           | map({
                               service: .key,
                               info:
                                 ((.value.labels // {})
                                  | to_entries
                                  | map(select(.key|startswith("info.")))
                                  | map({path: (.key | split(".")[1:]), value: .value})
                                  | reduce .[] as $i ({}; setpath($i.path; $i.value))
                                 )
                             })' 2>/dev/null)
            
            if [[ -n "$services_json" && "$services_json" != "null" ]]; then
                echo
                
                # Process each service
                echo "$services_json" | jq -r '.[] | select(.info.title) | "\(.service)\t\(.info | @json)"' | while IFS=$'\t' read -r service info_json; do
                    process_service_info_json "$service" "$info_json"
                done
            else
                log warn "No services found"
            fi
            ;;
            
        help|--help|-h)
            show_usage
            ;;
            
        *)
            log error "Unknown command: $cmd"
            echo
            show_usage
            exit 1
            ;;
    esac
}

# Execute main function with all arguments
main "$@"